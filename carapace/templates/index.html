<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Carapace Triage Graph</title>
    <script defer src="https://unpkg.com/alpinejs@3.14.1/dist/cdn.min.js"></script>
    <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
    <script src="https://unpkg.com/sigma@2.4.0/build/sigma.min.js"></script>
    <style>
      :root {
        --bg: #f3f4f7;
        --bg-accent: #ebeef7;
        --panel: #fcfdff;
        --panel-alt: #f7f9ff;
        --line: #d9dde9;
        --text: #101828;
        --muted: #5e6678;
        --accent: #3b82f6;
        --accent-soft: #dbeafe;
        --gold: #b7791f;
        --gold-soft: #fff2cc;
        --danger: #d92d20;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #0d1118;
          --bg-accent: #141b27;
          --panel: #111827;
          --panel-alt: #0f172a;
          --line: #273345;
          --text: #e5e7eb;
          --muted: #99a7bc;
          --accent: #60a5fa;
          --accent-soft: #1f2d48;
          --gold: #fbbf24;
          --gold-soft: #3b2f10;
          --danger: #fb7185;
        }
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        color: var(--text);
        font-family: "Avenir Next", "Segoe UI", "Inter", sans-serif;
        background:
          radial-gradient(circle at 12% 8%, var(--bg-accent), transparent 40%),
          radial-gradient(circle at 86% 10%, var(--bg-accent), transparent 35%),
          var(--bg);
      }

      .layout {
        display: grid;
        grid-template-columns: 380px 1fr;
        height: 100vh;
      }

      .sidebar {
        border-right: 1px solid var(--line);
        background: color-mix(in srgb, var(--panel) 92%, transparent);
        backdrop-filter: blur(8px);
        overflow: auto;
        padding: 14px;
      }

      .main {
        display: grid;
        grid-template-rows: auto minmax(280px, 43vh) minmax(280px, 1fr);
        min-height: 0;
      }

      .toolbar {
        display: flex;
        gap: 10px;
        align-items: center;
        border-bottom: 1px solid var(--line);
        background: color-mix(in srgb, var(--panel) 94%, transparent);
        backdrop-filter: blur(6px);
        padding: 10px 12px;
        flex-wrap: wrap;
      }

      .toolbar input,
      .toolbar select {
        padding: 6px 8px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--text);
      }

      .toolbar .grow { flex: 1; min-width: 160px; }

      .title {
        margin: 0;
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.01em;
      }

      .subtle {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
      }

      .filter-row {
        display: grid;
        gap: 8px;
        grid-template-columns: 1fr 86px 100px;
        margin: 10px 0;
      }

      .filter-row input,
      .filter-row select {
        width: 100%;
        min-width: 0;
        padding: 7px 8px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--text);
      }

      .queue-search {
        width: 100%;
        margin-bottom: 10px;
        padding: 7px 8px;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: var(--panel-alt);
        color: var(--text);
      }

      .card {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: linear-gradient(170deg, var(--panel-alt), var(--panel));
        padding: 10px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
      }

      .card:hover {
        border-color: color-mix(in srgb, var(--accent) 44%, var(--line));
        transform: translateY(-1px);
      }

      .card.active {
        border-color: var(--accent);
        box-shadow: 0 0 0 1px var(--accent) inset;
      }

      .card.canonical {
        border-left: 4px solid var(--gold);
      }

      .cluster-id {
        font-size: 12px;
        font-weight: 700;
        color: var(--muted);
      }

      .cluster-title {
        font-size: 13px;
        line-height: 1.35;
        margin-top: 4px;
      }

      .card-meta {
        margin-top: 8px;
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .pill {
        display: inline-block;
        font-size: 11px;
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 2px 8px;
        color: var(--muted);
      }

      .pill.gold {
        border-color: color-mix(in srgb, var(--gold) 45%, var(--line));
        background: color-mix(in srgb, var(--gold-soft) 65%, transparent);
        color: var(--gold);
      }

      .graph-wrap {
        min-height: 0;
        border-top: 1px solid var(--line);
        background: color-mix(in srgb, var(--panel) 94%, transparent);
      }

      .graph-title {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        border-bottom: 1px solid var(--line);
        background: color-mix(in srgb, var(--panel-alt) 88%, transparent);
      }

      .graph-title-main {
        font-size: 14px;
        font-weight: 700;
      }

      .graph {
        width: 100%;
        height: calc(100% - 42px);
      }

      button {
        border: 1px solid var(--line);
        background: var(--panel-alt);
        color: var(--text);
        border-radius: 8px;
        padding: 6px 10px;
        cursor: pointer;
      }

      button:hover {
        border-color: var(--accent);
        color: var(--accent);
      }

      .legend {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin: 8px 0 12px;
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
        color: var(--muted);
      }

      .dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
      }

      .selected-summary {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 9px;
        background: color-mix(in srgb, var(--panel-alt) 90%, transparent);
        margin-bottom: 10px;
      }

      .empty {
        color: var(--muted);
        font-size: 13px;
        margin-top: 8px;
      }
    </style>
  </head>
  <body x-data="triagePage()" x-init="init()">
    <div class="layout">
      <aside class="sidebar">
        <h2 class="title">Carapace Graph Workbench</h2>
        <div class="subtle" style="margin:6px 0 10px;">
          Queue-first triage. Top map = cluster topology. Bottom graph = selected cluster detail.
        </div>

        <div class="selected-summary" x-show="selectedClusterMeta" x-cloak>
          <div class="cluster-id" x-text="selectedClusterMeta ? ('#' + selectedClusterMeta.cluster_id) : ''"></div>
          <div class="cluster-title" x-text="selectedClusterMeta ? selectedCanonicalSnippet(selectedClusterMeta) : ''"></div>
          <div class="card-meta" x-show="selectedClusterMeta">
            <span class="pill" x-text="selectedClusterMeta ? selectedClusterMeta.cluster_type : ''"></span>
            <span class="pill gold" x-text="selectedClusterMeta ? ('members ' + selectedClusterMeta.member_count) : ''"></span>
            <span class="pill" x-text="selectedClusterMeta ? ('priority ' + selectedClusterMeta.priority) : ''"></span>
          </div>
        </div>

        <div class="filter-row">
          <select x-model="kind" @change="reloadAll()">
            <option value="all">all</option>
            <option value="duplicate_candidate">duplicate_candidate</option>
            <option value="linked_pair">linked_pair</option>
            <option value="mixed_pair">mixed_pair</option>
          </select>
          <input type="number" min="1" x-model.number="minMembers" @change="reloadAll()" title="min members" />
          <input type="number" min="10" max="2000" x-model.number="maxClusters" @change="reloadAll()" title="max clusters" />
        </div>

        <input class="queue-search" type="search" x-model="queueQuery" @input="applyQueueFilter()" placeholder="Filter by id, canonical, type..." />

        <div class="legend">
          <span class="legend-item"><span class="dot" style="background:#3b82f6"></span>PR</span>
          <span class="legend-item"><span class="dot" style="background:#ef4444"></span>Issue</span>
          <span class="legend-item"><span class="dot" style="background:#a855f7"></span>Author</span>
          <span class="legend-item"><span class="dot" style="background:var(--gold)"></span>Canonical</span>
        </div>

        <template x-for="cluster in clusters" :key="cluster.cluster_id">
          <div class="card" :class="{active: selectedClusterId===cluster.cluster_id, canonical: !!cluster.canonical}" @click="selectCluster(cluster.cluster_id)">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
              <div class="cluster-id" x-text="'#' + cluster.cluster_id"></div>
              <span class="pill" x-text="cluster.cluster_type"></span>
            </div>
            <div class="cluster-title" x-text="selectedCanonicalSnippet(cluster)"></div>
            <div class="card-meta">
              <span class="pill" x-text="'members ' + cluster.member_count"></span>
              <span class="pill" x-text="'priority ' + cluster.priority"></span>
              <span class="pill gold" x-show="cluster.canonical" x-text="cluster.canonical || ''"></span>
            </div>
          </div>
        </template>

        <div class="empty" x-show="clusters.length===0">No clusters match current filters.</div>
      </aside>

      <main class="main">
        <div class="toolbar">
          <label>Repo</label>
          <select x-model="repo" @change="reloadAll()">
            {% for r in repos %}
            <option value="{{ r }}" {% if r == repo %}selected{% endif %}>{{ r }}</option>
            {% endfor %}
          </select>

          <label>Atlas k</label>
          <input type="number" min="0" max="24" x-model.number="atlasEdgeK" @change="reloadMap()" />

          <label>Atlas d</label>
          <input type="number" step="0.01" min="0.01" max="2" x-model.number="atlasEdgeDistance" @change="reloadMap()" />

          <label>Detail edge≥</label>
          <input type="number" step="0.01" min="0" max="1" x-model.number="minDetailEdge" @change="reloadDetail()" />

          <label><input type="checkbox" x-model="includeAuthors" @change="reloadDetail()" /> authors</label>

          <button @click="reloadAll()">refresh</button>
          <span class="subtle grow" x-text="statusLine"></span>
        </div>

        <section class="graph-wrap">
          <div class="graph-title">
            <div>
              <div class="graph-title-main">Embedding Atlas</div>
              <div class="subtle" x-text="mapHelp"></div>
            </div>
            <span class="subtle" x-text="mapStats"></span>
          </div>
          <div id="cluster-map" class="graph"></div>
        </section>

        <section class="graph-wrap">
          <div class="graph-title">
            <div>
              <div class="graph-title-main">Cluster Detail</div>
              <div class="subtle" x-text="detailHelp"></div>
            </div>
            <span class="subtle" x-text="detailStats"></span>
          </div>
          <div id="cluster-detail" class="graph"></div>
        </section>
      </main>
    </div>

    <script>
      function triagePage() {
        return {
          repo: {{ repo|tojson }},
          kind: "all",
          minMembers: 2,
          maxClusters: 120,
          atlasEdgeK: 6,
          atlasEdgeDistance: 0.16,
          atlasMinSignal: 0,
          atlasMaxNodes: 12000,
          minDetailEdge: 0.2,
          includeAuthors: false,
          queueQuery: "",
          allClusters: [],
          clusters: [],
          selectedClusterId: null,
          selectedClusterMeta: null,
          mapSigma: null,
          detailSigma: null,
          mapGraph: null,
          detailGraph: null,
          statusLine: "",
          mapStats: "",
          detailStats: "",
          mapMode: "embedding_atlas",
          mapHelp: "All open entities in embedding space. Zoom controls density; click any node to jump to its cluster.",
          detailHelp: "Canonical nodes are gold. Text density increases as you zoom in.",

          init() {
            this.reloadAll();
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => {
              this.refreshRenderers();
            });
          },

          palette() {
            const dark = window.matchMedia("(prefers-color-scheme: dark)").matches;
            if (dark) {
              return {
                cluster: "#60a5fa",
                pr: "#4f8cff",
                issue: "#fb7185",
                author: "#a78bfa",
                canonical: "#fbbf24",
                edgeRef: "#f59e0b",
                edgeAuthor: "#8b5cf6",
                edgeBridge: "#38bdf8",
                edgeAtlas: "#64748b",
                edgeSimilarity: "#94a3b8",
                edgeFaint: "#334155",
                selected: "#22d3ee",
              };
            }
            return {
              cluster: "#1d4ed8",
              pr: "#2563eb",
              issue: "#dc2626",
              author: "#7c3aed",
              canonical: "#b7791f",
              edgeRef: "#b45309",
              edgeAuthor: "#7c3aed",
              edgeBridge: "#0f766e",
              edgeAtlas: "#64748b",
              edgeSimilarity: "#334155",
              edgeFaint: "#cbd5e1",
              selected: "#0ea5e9",
            };
          },

          truncate(text, limit = 80) {
            const value = String(text || "");
            if (value.length <= limit) return value;
            return `${value.slice(0, Math.max(0, limit - 1))}…`;
          },

          selectedCanonicalSnippet(cluster) {
            if (!cluster) return "";
            if (cluster.canonical_title) {
              return this.truncate(cluster.canonical_title, 92);
            }
            if (cluster.canonical) {
              return cluster.canonical;
            }
            return "No canonical selected yet";
          },

          applyQueueFilter() {
            const query = this.queueQuery.trim().toLowerCase();
            if (!query) {
              this.clusters = [...this.allClusters];
            } else {
              this.clusters = this.allClusters.filter((cluster) => {
                return [
                  cluster.cluster_id,
                  cluster.cluster_type,
                  cluster.canonical,
                  cluster.canonical_title,
                ]
                  .filter(Boolean)
                  .some((value) => String(value).toLowerCase().includes(query));
              });
            }
            if (!this.selectedClusterId || !this.clusters.find((row) => row.cluster_id === this.selectedClusterId)) {
              this.selectedClusterId = this.clusters.length ? this.clusters[0].cluster_id : null;
            }
            this.syncSelectedMeta();
          },

          syncSelectedMeta() {
            this.selectedClusterMeta = this.allClusters.find((row) => row.cluster_id === this.selectedClusterId) || null;
          },

          nodeColor(kind, canonical = false) {
            const palette = this.palette();
            if (canonical) return palette.canonical;
            if (kind === "cluster") return palette.cluster;
            if (kind === "pr") return palette.pr;
            if (kind === "issue") return palette.issue;
            if (kind === "author") return palette.author;
            return "#94a3b8";
          },

          edgeColor(kind) {
            const palette = this.palette();
            if (kind === "references") return palette.edgeRef;
            if (kind === "authored_by") return palette.edgeAuthor;
            if (kind === "cluster_bridge") return palette.edgeBridge;
            if (kind === "embedding_neighbor") return palette.edgeAtlas;
            if (kind === "similarity") return palette.edgeSimilarity;
            return palette.edgeFaint;
          },

          edgeSize(kind, weight) {
            if (kind === "cluster_bridge") return Math.max(0.9, Math.min(7.0, 0.9 + Math.log1p(Math.max(0, weight)) * 1.9));
            if (kind === "embedding_neighbor") return Math.max(0.4, Math.min(2.2, 0.3 + Math.max(0, weight) * 1.8));
            if (kind === "similarity") return Math.max(0.8, Math.min(6.5, 0.6 + Math.max(0, weight) * 5.2));
            if (kind === "references") return 1.4;
            if (kind === "authored_by") return 1.0;
            return 0.9;
          },

          atlasVisibilityBudget(ratio) {
            if (ratio >= 4.0) return 180;
            if (ratio >= 2.7) return 420;
            if (ratio >= 1.8) return 1100;
            if (ratio >= 1.2) return 2600;
            if (ratio >= 0.7) return 7000;
            return Number.POSITIVE_INFINITY;
          },

          atlasNodeVisible(attrs, ratio, hovered = false) {
            if (attrs.kind === "author") {
              return ratio < 1.4 || hovered;
            }
            if (attrs.canonical) return true;
            if (this.selectedClusterId && attrs.clusterId && attrs.clusterId === this.selectedClusterId) return true;
            if (hovered) return true;
            const rank = Number(attrs.atlasRank || 10 ** 9);
            return rank <= this.atlasVisibilityBudget(ratio);
          },

          prepareAtlasGraph(graph) {
            const ranked = graph
              .nodes()
              .map((id) => ({
                id,
                signal: Number(graph.getNodeAttribute(id, "signal") || 0),
                canonical: Boolean(graph.getNodeAttribute(id, "canonical")),
              }))
              .sort((a, b) => {
                if (a.canonical !== b.canonical) return Number(b.canonical) - Number(a.canonical);
                return b.signal - a.signal;
              });
            ranked.forEach((item, idx) => {
              graph.setNodeAttribute(item.id, "atlasRank", idx + 1);
            });
          },

          applyForce(graph, strength = -44, distance = 52, ticks = 190) {
            const nodes = graph.nodes().map((id) => ({
              id,
              x: graph.getNodeAttribute(id, "x"),
              y: graph.getNodeAttribute(id, "y"),
              size: graph.getNodeAttribute(id, "size"),
            }));
            const links = graph.edges().map((eid) => ({ source: graph.source(eid), target: graph.target(eid) }));
            const sim = d3
              .forceSimulation(nodes)
              .force("charge", d3.forceManyBody().strength(strength))
              .force("link", d3.forceLink(links).id((d) => d.id).distance(distance).strength(0.23))
              .force("center", d3.forceCenter(0, 0))
              .force("collision", d3.forceCollide().radius((d) => Math.max(1.5, (d.size || 2) * 1.2)).iterations(2));
            sim.stop();
            for (let i = 0; i < ticks; i += 1) sim.tick();
            for (const n of nodes) graph.mergeNodeAttributes(n.id, { x: n.x, y: n.y });
          },

          makeGraph(elements, { mode }) {
            const Graph = graphology.Graph;
            const g = new Graph({ multi: true, allowSelfLoops: false });
            const nodes = elements?.nodes || [];
            const edges = elements?.edges || [];

            nodes.forEach((node, idx) => {
              const d = node.data || {};
              const id = String(d.id || `n-${idx}`);
              const kind = String(d.kind || "");
              const canonical = Boolean(d.canonical) || (mode === "cluster-map" && Boolean(d.canonical_id));
              const baseSize = Math.max(2.2, Number(d.size || 10) / 6.2);
              const size = canonical ? baseSize * 1.25 : baseSize;
              const hasX = typeof d.x === "number";
              const hasY = typeof d.y === "number";
              g.addNode(id, {
                kind,
                label: String(d.label || id),
                shortLabel: String(d.short_label || d.label || id),
                canonicalTitle: String(d.canonical_title || ""),
                clusterId: String(d.cluster_id || ""),
                canonical,
                size,
                color: this.nodeColor(kind, canonical),
                x: hasX ? Number(d.x) * 100 : (Math.random() - 0.5) * 60,
                y: hasY ? Number(d.y) * 100 : (Math.random() - 0.5) * 60,
                memberCount: Number(d.member_count || 0),
                priority: Number(d.priority || 0),
                signal: Number(d.signal || 0),
                forceLabel: canonical,
              });
            });

            edges.forEach((edge, idx) => {
              const d = edge.data || {};
              const source = String(d.source || "");
              const target = String(d.target || "");
              if (!g.hasNode(source) || !g.hasNode(target) || source === target) return;
              const kind = String(d.kind || "");
              const weight = Number(d.weight || 0);
              g.addEdgeWithKey(String(d.id || `e-${idx}`), source, target, {
                kind,
                weight,
                tier: String(d.tier || ""),
                size: this.edgeSize(kind, weight),
                color: this.edgeColor(kind),
              });
            });

            if (mode === "cluster-map") {
              this.applyForce(g, -30, 40, 140);
            } else if (mode === "atlas") {
              this.applyForce(g, -6, 14, 20);
            } else {
              this.applyForce(g, -52, 56, 210);
            }
            return g;
          },

          labelForNode(attrs, ratio, target, highlighted) {
            const title = String(attrs.label || "");
            const shortLabel = String(attrs.shortLabel || title);
            const canonicalTitle = String(attrs.canonicalTitle || "");

            if (target === "map") {
              if (this.mapMode === "embedding_atlas") {
                if (attrs.kind === "author") {
                  if (ratio > 1.3 && !highlighted) return "";
                  return ratio > 0.9 ? this.truncate(title, 22) : this.truncate(title, 42);
                }
                if (ratio > 2.7 && !highlighted) return "";
                if (ratio > 1.8 && !highlighted && !attrs.canonical) return "";
                if (ratio > 1.1) return shortLabel;
                if (ratio > 0.75) return this.truncate(title, 40);
                return this.truncate(title, 88);
              }
              if (attrs.kind !== "cluster") {
                if (ratio > 2.5 && !highlighted) return "";
                if (ratio > 1.5 && !highlighted && !attrs.canonical) return "";
                if (ratio > 1.0) return shortLabel;
                if (ratio > 0.7) return this.truncate(title, 44);
                return this.truncate(title, 92);
              }
              if (ratio > 2.2 && !highlighted) return "";
              if (ratio > 1.25) return shortLabel;
              if (ratio > 0.72) {
                if (canonicalTitle) return `${shortLabel}: ${this.truncate(canonicalTitle, 42)}`;
                return this.truncate(shortLabel, 42);
              }
              if (canonicalTitle) return `${shortLabel} • ${this.truncate(canonicalTitle, 88)}`;
              return this.truncate(title, 88);
            }

            if (ratio > 2.5 && !highlighted && attrs.kind !== "author") return "";
            if (ratio > 1.6 && attrs.kind === "author") return "";
            if (ratio > 1.6) return this.truncate(title, 20);
            if (ratio > 0.95) return this.truncate(title, 44);
            return this.truncate(title, 92);
          },

          reduceNode(target, node, attrs, view) {
            const reduced = { ...attrs };
            const ratio = view.zoomRatio || 1;
            const hovered = view.hoverNode === node;
            const selectedCluster =
              target === "map" &&
              ((attrs.kind === "cluster" && node === this.selectedClusterId) ||
                (attrs.kind !== "cluster" && attrs.clusterId && attrs.clusterId === this.selectedClusterId));
            const highlighted = hovered || selectedCluster || Boolean(attrs.canonical);

            if (target === "map" && this.mapMode === "embedding_atlas") {
              if (!this.atlasNodeVisible(attrs, ratio, hovered)) {
                reduced.hidden = true;
                return reduced;
              }
            }

            if (selectedCluster) {
              reduced.size = attrs.size * 1.34;
              reduced.color = this.palette().selected;
              reduced.zIndex = 40;
              reduced.forceLabel = true;
            } else if (attrs.canonical) {
              reduced.color = this.palette().canonical;
              reduced.size = attrs.size * 1.15;
              reduced.zIndex = 30;
              reduced.forceLabel = ratio < 1.35;
            }

            if (hovered) {
              reduced.size = (reduced.size || attrs.size) * 1.12;
              reduced.zIndex = 60;
              reduced.forceLabel = true;
            }

            reduced.label = this.labelForNode(attrs, ratio, target, highlighted);
            return reduced;
          },

          reduceEdge(target, edge, attrs, view, graph) {
            const reduced = { ...attrs };
            const ratio = view.zoomRatio || 1;

            if (target === "map" && attrs.kind === "cluster_bridge") {
              if (ratio > 1.6 && attrs.weight < 2.0) reduced.hidden = true;
              if (ratio > 1.25 && attrs.weight < 1.2) reduced.hidden = true;
            }
            if (target === "map" && attrs.kind === "embedding_neighbor") {
              const [sourceNode, targetNode] = graph.extremities(edge);
              const sourceAttrs = graph.getNodeAttributes(sourceNode);
              const targetAttrs = graph.getNodeAttributes(targetNode);
              const sourceHovered = view.hoverNode === sourceNode;
              const targetHovered = view.hoverNode === targetNode;
              if (
                this.mapMode === "embedding_atlas" &&
                (!this.atlasNodeVisible(sourceAttrs, ratio, sourceHovered) ||
                  !this.atlasNodeVisible(targetAttrs, ratio, targetHovered))
              ) {
                reduced.hidden = true;
                return reduced;
              }
              if (ratio > 1.5 && attrs.weight < 0.35) reduced.hidden = true;
              if (ratio > 0.95 && attrs.weight < 0.2) reduced.hidden = true;
              if (ratio > 2.5 && attrs.weight < 0.6) reduced.hidden = true;
            }

            if (target === "detail") {
              if (attrs.kind === "authored_by" && ratio > 1.3) reduced.hidden = true;
              if (attrs.kind === "similarity" && attrs.weight < this.minDetailEdge + 0.05 && ratio > 1.4) reduced.hidden = true;
            }

            if (this.selectedClusterId && target === "map" && attrs.kind === "cluster_bridge") {
              const [source, targetNode] = graph.extremities(edge);
              if (source !== this.selectedClusterId && targetNode !== this.selectedClusterId) {
                reduced.color = this.palette().edgeFaint;
              }
            }
            if (this.selectedClusterId && target === "map" && attrs.kind === "embedding_neighbor") {
              const [source, targetNode] = graph.extremities(edge);
              const sourceCluster = String(graph.getNodeAttribute(source, "clusterId") || "");
              const targetCluster = String(graph.getNodeAttribute(targetNode, "clusterId") || "");
              if (sourceCluster !== this.selectedClusterId && targetCluster !== this.selectedClusterId) {
                reduced.color = this.palette().edgeFaint;
              }
            }
            return reduced;
          },

          renderSigma(containerId, graph, target) {
            if (target === "map" && this.mapSigma) this.mapSigma.kill();
            if (target === "detail" && this.detailSigma) this.detailSigma.kill();

            const SigmaCtor = window.Sigma || (window.sigma && window.sigma.Sigma);
            if (!SigmaCtor) {
              this.statusLine = "sigma failed to load";
              return null;
            }

            const state = { zoomRatio: 1, hoverNode: null };
            const renderer = new SigmaCtor(graph, document.getElementById(containerId), {
              renderEdgeLabels: false,
              labelDensity: 0.18,
              labelGridCellSize: 90,
              labelRenderedSizeThreshold: 8,
              minCameraRatio: 0.03,
              maxCameraRatio: 16,
              zIndex: true,
              nodeReducer: (node, attrs) => this.reduceNode(target, node, attrs, state),
              edgeReducer: (edge, attrs) => this.reduceEdge(target, edge, attrs, state, graph),
            });

            const refreshState = () => {
              state.zoomRatio = renderer.getCamera().getState().ratio;
              renderer.refresh();
            };

            renderer.on("enterNode", ({ node }) => {
              state.hoverNode = node;
              renderer.refresh();
            });
            renderer.on("leaveNode", () => {
              state.hoverNode = null;
              renderer.refresh();
            });

            renderer.getCamera().on("updated", refreshState);
            refreshState();

            if (target === "map") {
              this.mapSigma = renderer;
              this.mapGraph = graph;
              renderer.on("clickNode", ({ node }) => {
                const attrs = graph.getNodeAttributes(node);
                if (attrs.kind === "cluster") {
                  this.selectCluster(String(node));
                  return;
                }
                if (attrs.clusterId) {
                  this.selectCluster(String(attrs.clusterId));
                }
              });
            } else {
              this.detailSigma = renderer;
              this.detailGraph = graph;
            }
            return renderer;
          },

          focusMapOnCluster(clusterId, animate = true) {
            if (!clusterId || !this.mapSigma || !this.mapGraph) return;
            const matching = this.mapGraph
              .nodes()
              .filter((node) => {
                const attrs = this.mapGraph.getNodeAttributes(node);
                if (attrs.kind === "cluster") return node === clusterId;
                return attrs.clusterId && attrs.clusterId === clusterId;
              });
            if (!matching.length) return;

            let minX = Infinity;
            let maxX = -Infinity;
            let minY = Infinity;
            let maxY = -Infinity;
            for (const node of matching) {
              const x = Number(this.mapGraph.getNodeAttribute(node, "x") || 0);
              const y = Number(this.mapGraph.getNodeAttribute(node, "y") || 0);
              minX = Math.min(minX, x);
              maxX = Math.max(maxX, x);
              minY = Math.min(minY, y);
              maxY = Math.max(maxY, y);
            }
            const x = (minX + maxX) / 2.0;
            const y = (minY + maxY) / 2.0;
            const spread = Math.max(maxX - minX, maxY - minY, 1);
            const ratio = Math.max(0.09, Math.min(1.6, spread / 190.0));
            const camera = this.mapSigma.getCamera();
            const targetState = { x, y, ratio };
            if (animate && typeof camera.animate === "function") {
              camera.animate(targetState, { duration: 420 });
            } else if (typeof camera.setState === "function") {
              camera.setState(targetState);
            }
          },

          refreshRenderers() {
            if (this.mapGraph) {
              this.renderSigma("cluster-map", this.mapGraph, "map");
            }
            if (this.detailGraph) {
              this.renderSigma("cluster-detail", this.detailGraph, "detail");
            }
          },

          async fetchJSON(path) {
            const res = await fetch(path);
            if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
            return await res.json();
          },

          async reloadAll() {
            this.statusLine = "loading...";
            try {
              await this.reloadQueue();
              await this.reloadMap();
              if (this.selectedClusterId) {
                await this.reloadDetail();
              } else {
                this.detailStats = "no cluster selected";
              }
              this.statusLine = "ready";
            } catch (err) {
              this.statusLine = String(err);
            }
          },

          async reloadQueue() {
            const params = new URLSearchParams({
              kind: this.kind,
              min_members: String(this.minMembers),
              limit: String(this.maxClusters),
            });
            const payload = await this.fetchJSON(`/api/repos/${encodeURIComponent(this.repo)}/clusters?${params.toString()}`);
            this.allClusters = payload.clusters || [];
            this.applyQueueFilter();
          },

          async reloadMap() {
            const params = new URLSearchParams({
              kind: this.kind,
              include_edges: "true",
              edge_k: String(this.atlasEdgeK),
              edge_max_distance: String(this.atlasEdgeDistance),
              min_signal: String(this.atlasMinSignal),
              max_nodes: String(this.atlasMaxNodes),
            });
            const payload = await this.fetchJSON(`/api/repos/${encodeURIComponent(this.repo)}/graph/atlas?${params.toString()}`);
            this.mapMode = payload.mode || "embedding_atlas";
            this.mapStats = `${payload.node_count} nodes / ${payload.edge_count} edges (${payload.mode})`;
            const graph = this.makeGraph(payload.elements, { mode: "atlas" });
            this.prepareAtlasGraph(graph);
            this.renderSigma("cluster-map", graph, "map");
            if (this.selectedClusterId) {
              this.focusMapOnCluster(this.selectedClusterId, false);
            }
          },

          async reloadDetail() {
            if (!this.selectedClusterId) {
              this.detailStats = "no cluster selected";
              return;
            }
            const params = new URLSearchParams({
              min_edge_score: String(this.minDetailEdge),
              include_authors: String(this.includeAuthors),
            });
            const payload = await this.fetchJSON(`/api/repos/${encodeURIComponent(this.repo)}/clusters/${encodeURIComponent(this.selectedClusterId)}/detail?${params.toString()}`);
            const c = payload.cluster || {};
            const canonicalSummary = [c.canonical_pr, c.canonical_issue].filter(Boolean).join(" / ");
            this.detailStats = `${payload.node_count} nodes / ${payload.edge_count} edges — ${c.cluster_type || ""}${canonicalSummary ? ` — ${canonicalSummary}` : ""}`;
            const graph = this.makeGraph(payload.elements, { mode: "cluster-detail" });
            this.renderSigma("cluster-detail", graph, "detail");
          },

          async selectCluster(clusterId) {
            if (!clusterId) return;
            this.selectedClusterId = clusterId;
            this.syncSelectedMeta();
            if (this.mapSigma) {
              this.mapSigma.refresh();
              this.focusMapOnCluster(clusterId, true);
            }
            await this.reloadDetail();
          },
        };
      }
    </script>
  </body>
</html>
