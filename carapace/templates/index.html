<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Carapace Graph</title>
    <script src="https://unpkg.com/htmx.org@1.9.12"></script>
    <script defer src="https://unpkg.com/alpinejs@3.14.1/dist/cdn.min.js"></script>
    <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-force@3"></script>
    <script src="https://unpkg.com/sigma@2.4.0/build/sigma.min.js"></script>
    <style>
      :root {
        --bg: #f6f6ef;
        --panel: #fffdf8;
        --text: #1f2a37;
        --muted: #6b7280;
        --line: #d9d4c7;
        --accent: #0f766e;
      }
      body { margin: 0; font-family: ui-sans-serif, -apple-system, Segoe UI, sans-serif; background: var(--bg); color: var(--text); }
      .layout { display: grid; grid-template-columns: 380px 1fr; height: 100vh; }
      .sidebar { border-right: 1px solid var(--line); background: var(--panel); overflow: auto; padding: 16px; }
      .main { display: grid; grid-template-rows: auto 1fr; }
      .toolbar { display: flex; gap: 8px; align-items: center; border-bottom: 1px solid var(--line); background: var(--panel); padding: 12px 16px; }
      .toolbar input, .toolbar select { padding: 6px 8px; border: 1px solid var(--line); border-radius: 8px; background: white; }
      #graph { width: 100%; height: 100%; }
      .cluster-card { border: 1px solid var(--line); border-radius: 10px; padding: 10px; margin-bottom: 8px; background: #ffffff; }
      .cluster-card h4 { margin: 0 0 6px; font-size: 14px; }
      .muted { color: var(--muted); font-size: 12px; }
      .pill { display:inline-block; padding:2px 8px; border:1px solid var(--line); border-radius:999px; font-size:11px; }
      button { border:1px solid var(--line); background:white; border-radius:8px; padding:6px 10px; cursor:pointer; }
      button:hover { border-color: var(--accent); color: var(--accent); }
    </style>
  </head>
  <body x-data="graphPage()" x-init="init()">
    <div class="layout">
      <aside class="sidebar">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <h2 style="margin:0;">Clusters</h2>
          <span class="muted" x-text="repo"></span>
        </div>
        <div class="muted" style="margin-bottom:12px;">Obsidian-style triage graph</div>

        <div style="display:flex; gap:6px; margin-bottom:10px;">
          <select x-model="kind" @change="reloadClusters()">
            <option value="all">all</option>
            <option value="duplicate_candidate">duplicate_candidate</option>
            <option value="linked_pair">linked_pair</option>
            <option value="mixed_pair">mixed_pair</option>
          </select>
          <input type="number" min="1" x-model="minMembers" @change="reloadClusters()" title="min members" />
        </div>

        <div id="clusters"
             hx-get="/ui/fragments/clusters"
             hx-trigger="load"
             :hx-vals="JSON.stringify({repo: repo, kind: kind, min_members: Number(minMembers)})"
             hx-swap="innerHTML"></div>
      </aside>

      <main class="main">
        <div class="toolbar">
          <label>Repo</label>
          <select x-model="repo" @change="reloadAll()">
            {% for r in repos %}
            <option value="{{ r }}" {% if r == repo %}selected{% endif %}>{{ r }}</option>
            {% endfor %}
          </select>

          <label>Min edge</label>
          <input type="number" step="0.01" min="0" max="1" x-model="minEdge" @change="reloadGraph()" />
          <label>Clusters</label>
          <input type="number" min="10" max="2000" x-model="maxClusters" @change="reloadGraph()" />
          <label><input type="checkbox" x-model="includeAuthors" @change="reloadGraph()" /> authors</label>
          <label>Layout</label>
          <select x-model="layoutMode" @change="reloadGraph()">
            <option value="auto">auto</option>
            <option value="elastic">elastic</option>
            <option value="fast">fast</option>
          </select>

          <button @click="focusAll()">all clusters</button>
          <span class="muted" x-text="graphStats"></span>
        </div>
        <div id="graph"></div>
      </main>
    </div>

    <script>
      function graphPage() {
        return {
          repo: {{ repo|tojson }},
          kind: "all",
          minMembers: 2,
          minEdge: 0.15,
          maxClusters: 60,
          includeAuthors: false,
          layoutMode: "auto",
          selectedCluster: null,
          sigma: null,
          graph: null,
          graphStats: "",

          init() {
            window.carapaceSelectCluster = (clusterId) => {
              this.selectedCluster = clusterId;
              this.reloadGraph();
            };
            this.reloadGraph();
          },

          reloadClusters() {
            const el = document.getElementById("clusters");
            el.setAttribute("hx-vals", JSON.stringify({ repo: this.repo, kind: this.kind, min_members: Number(this.minMembers) }));
            htmx.trigger(el, "load");
          },

          reloadAll() {
            this.selectedCluster = null;
            this.reloadClusters();
            this.reloadGraph();
          },

          focusAll() {
            this.selectedCluster = null;
            this.reloadGraph();
          },

          async reloadGraph() {
            const params = new URLSearchParams({
              min_edge_score: String(this.minEdge),
              max_clusters: String(this.maxClusters),
              include_authors: String(this.includeAuthors),
            });
            if (this.selectedCluster) params.set("cluster_id", this.selectedCluster);
            const res = await fetch(`/api/repos/${encodeURIComponent(this.repo)}/graph?${params.toString()}`);
            const payload = await res.json();
            this.graphStats = `${payload.node_count} nodes / ${payload.edge_count} edges [${payload.mode}]`;
            this.renderGraph(payload.elements);
          },

          colorForKind(kind) {
            if (kind === "cluster") return "#0f766e";
            if (kind === "pr") return "#2563eb";
            if (kind === "issue") return "#dc2626";
            if (kind === "author") return "#7c3aed";
            return "#94a3b8";
          },

          applyForceLayout(graph, useElasticLayout) {
            const nodeIds = graph.nodes();
            if (!nodeIds.length) return;
            const nodes = nodeIds.map((id) => ({
              id,
              x: graph.getNodeAttribute(id, "x"),
              y: graph.getNodeAttribute(id, "y"),
            }));
            const links = graph.edges().map((eid) => ({
              source: graph.source(eid),
              target: graph.target(eid),
            }));

            const sim = d3.forceSimulation(nodes)
              .force("charge", d3.forceManyBody().strength(useElasticLayout ? -55 : -30))
              .force("link", d3.forceLink(links).id((d) => d.id).distance(useElasticLayout ? 60 : 36).strength(0.22))
              .force("center", d3.forceCenter(0, 0))
              .force("collision", d3.forceCollide().radius((d) => Math.max(2.5, graph.getNodeAttribute(d.id, "size"))));

            sim.stop();
            const ticks = useElasticLayout ? 260 : 120;
            for (let i = 0; i < ticks; i += 1) sim.tick();
            sim.stop();

            for (const n of nodes) {
              graph.mergeNodeAttributes(n.id, { x: n.x, y: n.y });
            }
          },

          renderGraph(elements) {
            if (this.sigma) this.sigma.kill();
            this.sigma = null;
            this.graph = null;
            const nodeCount = (elements?.nodes || []).length;
            const showLabels = nodeCount <= 280;
            const useFastLayout = this.layoutMode === "fast" || (this.layoutMode === "auto" && nodeCount > 320);
            const useElasticLayout = this.layoutMode === "elastic" || (this.layoutMode === "auto" && nodeCount <= 320);

            const Graph = graphology.Graph;
            const graph = new Graph({ multi: true, allowSelfLoops: false });
            const nodeList = elements?.nodes || [];
            const edgeList = elements?.edges || [];

            nodeList.forEach((node, idx) => {
              const d = node.data || {};
              if (!d.id) return;
              const x = useFastLayout ? ((idx % 24) * 10) : ((Math.random() - 0.5) * 100);
              const y = useFastLayout ? (Math.floor(idx / 24) * 10) : ((Math.random() - 0.5) * 100);
              graph.addNode(String(d.id), {
                label: showLabels ? String(d.label || d.id) : "",
                size: Math.max(2.2, Number(d.size || 12) / 7),
                color: this.colorForKind(String(d.kind || "")),
                kind: String(d.kind || ""),
                x,
                y,
              });
            });

            edgeList.forEach((edge, idx) => {
              const d = edge.data || {};
              if (!d.source || !d.target) return;
              const source = String(d.source);
              const target = String(d.target);
              if (!graph.hasNode(source) || !graph.hasNode(target) || source === target) return;
              const kind = String(d.kind || "");
              const color = kind === "references" ? "#b45309"
                : kind === "authored_by" ? "#7c3aed"
                : kind === "cluster_bridge" ? "#0f766e"
                : kind === "in_cluster" ? "#0f766e"
                : "#475569";
              const size = kind === "similarity" ? Math.max(0.7, Number(d.weight || 0.3) * 2.4) : 1.0;
              graph.addEdgeWithKey(String(d.id || `e-${idx}`), source, target, { color, size, kind, weight: Number(d.weight || 0) });
            });

            if (!useFastLayout) this.applyForceLayout(graph, useElasticLayout);

            const renderer = new Sigma(graph, document.getElementById("graph"), {
              renderEdgeLabels: false,
              labelDensity: showLabels ? 0.08 : 0.0,
              labelGridCellSize: 120,
              minCameraRatio: 0.05,
              maxCameraRatio: 12,
              zIndex: true,
            });
            this.graph = graph;
            this.sigma = renderer;

            let focusedNode = null;
            const resetFocus = () => {
              focusedNode = null;
              renderer.setSetting("nodeReducer", null);
              renderer.setSetting("edgeReducer", null);
              renderer.refresh();
            };

            renderer.on("clickNode", ({ node }) => {
              focusedNode = node;
              const neighborhood = new Set(graph.neighbors(node));
              neighborhood.add(node);
              renderer.setSetting("nodeReducer", (n, data) => {
                if (neighborhood.has(n)) return data;
                return { ...data, color: "#d8dde5", label: "" };
              });
              renderer.setSetting("edgeReducer", (e, data) => {
                const ext = graph.extremities(e);
                if (ext.includes(node)) return data;
                return { ...data, color: "#e5e7eb", hidden: false };
              });
              renderer.refresh();
            });

            renderer.on("clickStage", () => resetFocus());
          },
        };
      }
    </script>
  </body>
</html>
